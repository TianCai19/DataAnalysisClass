---
title: "作业5"
author: "xxx"
date: "2020/11/11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r data1,include=FALSE}
heart <- data.frame(
    x1 = c(
        8.11, 9.36, 9.85, 2.55, 6.01, 9.64, 4.11, 8.90,
        7.71, 7.51, 8.06, 6.80, 8.68, 5.67, 8.10, 3.71,
        5.37, 9.89, 5.22, 4.71, 4.71, 3.36, 8.27
    ),
    x2 = c(
        261.01, 185.39, 249.58, 137.13, 231.34, 231.38, 260.25,
        259.91, 273.84, 303.59, 231.03, 308.90, 258.69,
        355.54, 476.69, 316.32, 274.57, 409.42, 330.34,
        331.47, 352.50, 347.31, 189.56
    ),
    x3 = c(
        13.23, 9.02, 15.61, 9.21, 14.27, 13.03, 14.72, 14.16,
        16.01, 19.14, 14.41,
        15.11, 14.02, 15.13, 7.38, 17.12, 16.75, 19.47, 18.19, 21.26,
        20.79, 17.90, 12.74
    ),
    x4 = c(
        7.36, 5.99, 6.11, 4.35, 8.79, 8.53, 10.02, 9.79, 8.79, 8.53, 6.15, 8.49,
        7.16, 9.43, 11.32, 8.17, 9.67, 10.49, 9.61, 13.72, 11.00, 11.19, 6.94
    )
)
G <- factor(rep(c(1, 2, 3), c(11, 7, 5)))
p <- c(11 / 23, 7 / 23, 5 / 23) ### p是先验概率:11/23,7/23,5/23
source("distinguish.distance.R") ## 打开
source("distinguish.bayes.R")
```
# 作业1

# 多类距离判别算法
```{r}
distinguish.distance(heart, G, var.equal = F)
```
由结果可知，当协方差不一致的时候,
第1,10,13,17,19号样本错判，回代的判别正确率为
23- 5= 18,18/23=78.26%
```{r}
distinguish.distance(heart, G, var.equal = T)
```
由结果可知，当协方差一致的时候，第7,10,13,17,23号样本错判，回代的判别正确率为23-5= 18,18/23=78.26%


## 多类贝叶斯离判别算法，
先验概率分别为: 11/23,7/23,5/23
```{r}
distinguish.bayes(heart, G, p, var.equal = F)
```
由结果可知，当协方差不一-致的时候，第1,10,13,17,19,21,22,23,号样本错判，回代的判别正确率为23-8= 15,15/23=65.22%
```{r}
distinguish.bayes(heart, G, p, var.equal = T)
```
由结果可知，当协方差一致的时候，第13,17,19,23,号样本错判，回代的判别 正确率为23-4= 19,19/23=82.61%


# 作业2

```{r data2,include=FALSE}
DXBZ <-
    c(
        9.30, 4.67, 0.96, 1.38, 1.48, 2.60, 2.15,
        2.14, 6.53, 1.47, 1.17, 0.88, 1.23, 0.99,
        0.98, 0.85, 1.57, 1.14, 1.34, 0.79, 1.24,
        0.96, 0.78, 0.81, 0.57, 1.67, 1.10, 1.49, 1.61, 1.85
    )
CZBZ <-
    c(
        30.55, 29.38, 24.69, 29.24, 25.47, 32.32,
        26.31, 28.46, 31.59, 26.43, 23.74,
        19.97, 16.87, 18.84, 25.18, 26.55, 23.16,
        22.57, 23.04, 19.14, 22.53, 21.65, 14.65, 13.85,
        3.85, 24.36, 16.85, 17.76, 20.27, 20.66
    )
WMBZ <-
    c(
        8.70, 8.92, 15.21, 11.30, 15.39, 8.81, 10.49,
        10.87, 11.04, 17.23, 17.46, 24.43,
        15.63, 16.22, 16.87, 16.15, 15.79,
        12.10, 10.45, 10.61, 13.97,
        16.24, 24.27, 25.44, 44.43, 17.62, 27.93, 27.70, 22.06, 12.75
    )
BZ <- data.frame(DXBZ, CZBZ, WMBZ)

name <- c(
    "北京", "天津", "河北", "山西", "内蒙古", "辽宁",
    "吉林", "黑龙江", "上海", "江苏", "浙江", "安徽", "福建", "江西",
    "山东", "河南", "湖北", "湖南", "广东", "广西",
    "海南", "四川", "贵州", "云南", "西藏", "陕西", "甘肃", "青海", "宁夏", "新疆"
)

BZ <-
    data.frame(DXBZ, CZBZ, WMBZ, row.names = name)
```
#### 1)计算样本的距离，分别用最长距离法、均值法、重心法和Ward法作聚类分析，并画出相应的谱系图．如果將所有样本分为4类，试写出各种方
法的分类结果；
```{r }
BZ.scale <- scale(BZ)
#### 将数据框BZ中数据进行标准化
BZ.dist <- dist(BZ.scale, method = "euclidean")
#### 对数据使用Euclid距离
BZ.complete <- hclust(BZ.dist, "complete")
#### 最长距离法做聚类分析
BZ.average <- hclust(BZ.dist, "average")
### 类平均做聚类分析
BZ.centroid <- hclust(BZ.dist, "centroid")
### 重心法做聚类分析
BZ.ward <- hclust(BZ.dist, "ward.D")
#### W ard法做聚类分析
# opar <- par(mfrow = c(2, 2))
plot(BZ.complete, hang = -1, main = "CompleteDendrogram")
re.c <- rect.hclust(BZ.complete, k = 4, border = "green")
plot(BZ.average, hang = -1, main = "AverageDendrogram")
re.a <- rect.hclust(BZ.average, k = 4, border = "blue")
plot(BZ.centroid, hang = -1, main = "CentroidDendrogram")
re.o <- rect.hclust(BZ.centroid, k = 4, border = "red")
plot(BZ.ward, hang = -1, main = "WardDendrogram")
re.w <- rect.hclust(BZ.ward, k = 4, border = "grey")
```

### 2）用动态聚类方法（共分为4类），给出相应的分类结果
```{r}
BZ.km <- kmeans(BZ.scale, 4, nstart = 20)
sort(BZ.km$cluster)
```